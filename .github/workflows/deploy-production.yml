name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

# Production 배포는 한 번에 하나씩만
concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  # Docker 이미지 빌드 및 푸시
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest

    strategy:
      matrix:
        service:
          - backend
          - frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to NCP Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.NCP_REGISTRY_URL }}
          username: ${{ secrets.NCP_REGISTRY_USERNAME }}
          password: ${{ secrets.NCP_REGISTRY_PASSWORD }}

      - name: Extract version from package.json
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=v${VERSION}" >> $GITHUB_OUTPUT

      - name: Build and push ${{ matrix.service }} image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ${{ secrets.NCP_REGISTRY_URL }}/bookstcamp-${{ matrix.service }}:production-latest
            ${{ secrets.NCP_REGISTRY_URL }}/bookstcamp-${{ matrix.service }}:${{ steps.version.outputs.version }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}

      - name: Image built successfully
        run: |
          echo "${{ matrix.service }} image built and pushed"
          echo "Tags: production-latest, ${{ steps.version.outputs.version }}"

  # Production 배포 (자동)
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Setup dotenvx
        run: |
          npm install -g @dotenvx/dotenvx

      - name: Create temporary env file with decrypted DATABASE_URL
        env:
          DOTENV_PRIVATE_KEY_PRODUCTION: ${{ secrets.DOTENVX_PRIVATE_KEY_PRODUCTION }}
          NCP_REGISTRY_URL: ${{ secrets.NCP_REGISTRY_URL }}
          NCP_REGISTRY_USERNAME: ${{ secrets.NCP_REGISTRY_USERNAME }}
          NCP_REGISTRY_PASSWORD: ${{ secrets.NCP_REGISTRY_PASSWORD }}
        run: |
          # DATABASE_URL 복호화
          DATABASE_URL=$(dotenvx get DATABASE_URL -f .env.production)

          # deploy.env 생성
          {
            echo "ENVIRONMENT=production"
            echo "NCP_REGISTRY_URL=${NCP_REGISTRY_URL}"
            echo "NCP_REGISTRY_USERNAME=${NCP_REGISTRY_USERNAME}"
            echo "NCP_REGISTRY_PASSWORD=${NCP_REGISTRY_PASSWORD}"
            echo "DOTENV_PRIVATE_KEY_PRODUCTION=${DOTENV_PRIVATE_KEY_PRODUCTION}"
            echo "DATABASE_URL=${DATABASE_URL}"
          } > /tmp/deploy.env
          chmod 600 /tmp/deploy.env

      - name: Copy deployment files to server
        run: |
          scp -r scripts/ ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:~/bookstcamp/
          scp -r nginx/ ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:~/bookstcamp/
          scp docker-compose.yml ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:~/bookstcamp/docker-compose.yml
          scp .env.production ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:~/bookstcamp/.env.production
          scp /tmp/deploy.env ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:~/bookstcamp/.deploy.env
          rm /tmp/deploy.env

      - name: Deploy on production server
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} << 'EOF'
            set -e
            cd ~/bookstcamp

            # 환경변수 로드 (NCP_REGISTRY_*, DOTENV_PRIVATE_KEY_PRODUCTION 등)
            set -a
            source .deploy.env
            set +a

            # 배포 스크립트 실행
            chmod +x scripts/*.sh
            ./scripts/deploy.sh prod

            # 보안: 배포 완료 후 삭제
            rm -f .deploy.env
          EOF

      - name: Verify deployment
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} << 'EOF'
            cd ~/bookstcamp

            echo "Waiting for containers to start..."
            sleep 10

            echo "=== Container Status ==="
            docker ps --format "table {{.Names}}\t{{.Status}}"
          EOF

      - name: Post-deployment monitoring
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} << 'EOF'
            cd ~/bookstcamp

            echo "=== Deployment Summary ==="
            echo "Deployed at: $(date)"
            echo ""
            echo "=== Running Containers ==="
            docker compose -f docker-compose.yml ps
            echo ""
            echo "=== Container Resource Usage ==="
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" $(docker compose -f docker-compose.yml ps -q)
          EOF

      - name: Deployment successful
        run: |
          echo "Production deployment completed successfully!"
          echo "Deployed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

  # 모니터링 서버 배포
  deploy-monitoring:
    name: Deploy Monitoring Server
    runs-on: ubuntu-latest
    needs: deploy

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.MONITORING_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.MONITORING_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Copy monitoring files to server
        run: |
          ssh ${{ secrets.MONITORING_SERVER_USER }}@${{ secrets.MONITORING_SERVER_HOST }} 'mkdir -p ~/bookstcamp/grafana'
          scp docker-compose.monitoring.yml ${{ secrets.MONITORING_SERVER_USER }}@${{ secrets.MONITORING_SERVER_HOST }}:~/bookstcamp/
          scp prometheus.monitoring.yml ${{ secrets.MONITORING_SERVER_USER }}@${{ secrets.MONITORING_SERVER_HOST }}:~/bookstcamp/
          scp -r grafana/ ${{ secrets.MONITORING_SERVER_USER }}@${{ secrets.MONITORING_SERVER_HOST }}:~/bookstcamp/

      - name: Deploy monitoring stack
        env:
          GRAFANA_ADMIN_USER: ${{ secrets.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
        run: |
          ssh ${{ secrets.MONITORING_SERVER_USER }}@${{ secrets.MONITORING_SERVER_HOST }} << EOF
            set -e
            cd ~/bookstcamp

            # .env.monitoring 생성
            cat > .env.monitoring << 'ENVEOF'
          GRAFANA_ADMIN_USER=${GRAFANA_ADMIN_USER}
          GRAFANA_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
          ENVEOF
            chmod 600 .env.monitoring

            # 기존 컨테이너 중지 및 최신 이미지 pull
            docker compose -f docker-compose.monitoring.yml --env-file .env.monitoring down || true
            docker compose -f docker-compose.monitoring.yml --env-file .env.monitoring pull

            # 컨테이너 시작
            docker compose -f docker-compose.monitoring.yml --env-file .env.monitoring up -d

            echo "Waiting for containers to start..."
            sleep 10

            echo "=== Monitoring Container Status ==="
            docker ps --format "table {{.Names}}\t{{.Status}}"
          EOF

      - name: Monitoring deployment successful
        run: |
          echo "Monitoring server deployment completed!"

  # 배포 실패 시 자동 롤백
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Execute rollback
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} << 'EOF'
            set -e
            cd ~/bookstcamp

            echo "Executing automatic rollback..."
            ./scripts/rollback.sh prod

            echo "Waiting for services to stabilize..."
            sleep 10

            echo "=== Container Status ==="
            docker ps --format "table {{.Names}}\t{{.Status}}"
          EOF

      - name: Rollback completed
        run: |
          echo "Production deployment failed and was rolled back"
          echo "Please check the logs and fix the issue before redeploying"
          echo "Investigate: ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} 'cd ~/bookstcamp && docker compose -f docker-compose.yml logs'"
